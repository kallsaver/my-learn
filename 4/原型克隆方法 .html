<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>无标题文档</title>
</head>

<body>
</body>
<script>
	//ECMAscript5提供了Object.create方法,可以用来克隆对象
	
	var Plane=function(){
		this.blood=100;							//this.blood是加在Plane层的  
		this.attackLevel=1;
		this.defenseLevel=1;
		Plane.prototype.speak=function(){		//Plane.prototype就是上层Object层 
			alert(1)							//speak方法是加在plane1的上层Object(还有一个底层Object)
		}
		this.address={
			city:"beijing"
		}
	}
	
	var plane1=new Plane();
	console.log(plane1)
	
/*	
	var plane2=Object.create(plane1)	
	console.log(plane1)
	console.log(plane2)
	console.log(plane1 instanceof Plane) //true
	console.log(plane2 instanceof Plane)	//true*/
	
	//在不支持Object.create方法的浏览器中,则可以使用下面的代码
	
	function create(obj){
		var F=function(){}
			
		F.prototype=obj;  //把底层Function删掉了
		return new F();		//new F() 的原型是obj  其次是Plane
		
	}
	
	var plane2=create(plane1)
	console.log(plane1)		//是个Plane
	console.log(plane2)		//是个F 也是个Plane      F因为被return 出来了 生命周期得到延续
	console.log(plane1 instanceof Plane) //true
	console.log(plane2 instanceof Plane)	//true*/
	plane2.blood=500
	alert(plane1.blood) //100
	
	//原型克隆方法的弊端是在一维属性中拿的是值  如果一维属性是个对象或者数组的时候 拿的是引用地址了
	plane2.address.city="shanghai"
	alert(plane1.address.city)
	
	
</script>
</html>
