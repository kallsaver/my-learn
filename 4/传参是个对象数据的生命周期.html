<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>无标题文档</title>
</head>

<body>
</body>
<script>
	//没有问题 
/*	function run(){
		var a=6
		var b={"name":"john"}
		
		a=b
		return a
	
	}
	
	var c=run()
	
	console.log(c)*/
	
	
	function isClass(value){
        if (value===null){
            return "null";
        }
        if(value===undefined){
            return "undefined";
        }
        return Object.prototype.toString.call(value).slice(8,-1)
    }
	
	function free(obj){
		
	}
	
	
	
	//回调函数传的参数是对象的时候:	 
	//回调函数和主函数是兄弟函数 要共用一个变量时  主函数外面再套一个函数 
	function parent(){
		var c=[];
		
		function run(fn){
	
			var b=[{"name":"john"},{"name":"john"}];
			fn&&fn(b)
			b=null  //不能模仿ajax 不管用 只是把b的栈地址清空了
			
			
		}
		
		run(function(obj){	//obj拿到b的引用地址
			//console.log(c)	//在共同父级函数体中找到c这个变量
			c=obj;					
			return c
		})				//主函数也结束 主函数体中的b不会被销毁 所以c最终拿到b的引用地址
				//如果是ajax请求 b的引用地址会被运行请求完后会主动删除的 否认内部会爆
				//在ajax请求保存数据时要用二维来保存数据  
				//c.push(obj)或者c[0]=obj 不能用c=obj 
					
		return c;	
	}
		

	
	var f=parent();
	console.log(f)
	
	

</script>
</html>
