<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
	<script>
		// https://www.cnblogs.com/whybxy/p/7645578.html
		
		console.log(new Promise(function(resolve, reject){}));
		
		// Promise静态方法
		Promise.resolve('Promise静态方法resolve').then(function(data){
			console.log(data);
		});
		
		Promise.reject('Promise静态方法reject').catch(function(data){
			console.log(data);
		});
		
		function runAsync () {
			console.log('runAsync')
			var p = new Promise(function(resolve, reject) {
				setTimeout(function() {
					resolve('runAsync成功');
				}, 2000);
			});
			return p;
		}
		
		runAsync().then(function(resolveData) {
			console.log(resolveData);
		});
		
		// 链式调用
		function source1$ () {
			var p = new Promise(function(resolve, reject) {
				setTimeout(function() {
					console.log('source1$异步');
					resolve('source1$成功');
				}, 3000);
			});
			return p;
		}
		
		function source2$ () {
			var p = new Promise(function(resolve, reject) {
				setTimeout(function() {
					console.log('source2$异步');
					resolve('source2$成功');
				}, 1000);
			});
			return p;
		}
		
		source1$().then(function() {
			console.log('source1$then函数执行');
			return source2$();
		}).then(function() {
			console.log('source2$then函数执行');
		});
		
		// 更方便的链式调用
		function source3$ () {
			// return一个Promise链时,如果有then函数,最终会return then函数
			// 而then会得到上游的的resolve,如果没有就undefined
			return new Promise(function(resolve, reject) {
				setTimeout(function() {
					console.log('source3$异步');
					resolve('source3$成功');
				}, 3000);
			}).then(function(data) {
				// source3$最终return的是这里的指针
				return Promise.resolve(data);
			}).then(function(data){
				return Promise.resolve('证明了Promise链的then机制');
			});
		}
		
		source3$().then(function (data) {
			console.log(data);
		});
			
		
		
		// 静态方法Promise.all,所有依赖的Promise都成功才会执行then函数,
		// 类似$.when或者RxJs的zip
		
		function zip1$ () {
			var p = new Promise(function(resolve, reject) {
				setTimeout(function() {
					console.log('zip1$异步');
					resolve('zip1$成功');
				}, 3000);
			});
			return p;
		}
		
		function zip2$ () {
			var p = new Promise(function(resolve, reject) {
				setTimeout(function() {
					console.log('zip2$异步');
					resolve('zip2$成功');
				}, 5000);
			});
			return p;
		}
		
		// Promise.all的参数是个数组,里面的元素是Promise对象,
		// then回调函数函数的参数也是数组
		Promise.all([zip1$(), zip2$()]).then(function (data){
			console.log('Promise.all的then函数执行');
			console.log(data);
		});
		
		// Promise静态方法race,
		
		function race1$ () {
			var p = new Promise(function(resolve, reject) {
				setTimeout(function() {
					console.log('race1$异步');
					resolve('race1$成功');
				}, 6000);
			});
			return p;
		}
		
		function race2$ () {
			var p = new Promise(function(resolve, reject) {
				setTimeout(function() {
					console.log('race2$异步');
					resolve('race2$成功');
				}, 7000);
			});
			return p;
		}
		
		// 依赖的Promise都会执行,但是其中最快的resolve后会触发race的then函数
		Promise.race([race1$(), race2$()]).then(function (data){
			console.log('Promise.race的then函数执行');
			console.log(data);
		});
		
		
		
		// catch
		
		function catch1$ () {
			var p = new Promise(function(resolve, reject) {
				setTimeout(function() {
					reject('oh, no!');
				}, 7000);
			});
			return p;
		}
		
		catch1$().then(function() {
			// catch之前的then是成功的then
			alert(5);
		}).catch(function (data) {
			console.log('catch' + data);
		}).then(function() {
			// catch之后的then是在catch触发后可以无限触发,没有意义的存在
			// 而且影响了封装
			alert(55);
		});
		
		
		
		
		
		
		
		
	</script>
</html>
