<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
	<script src="js/util.js"></script>
	<script type="text/javascript" src="js/util2.js" ></script>
	<script>
		//理解了异步任务的任务队列(异步)后
		
		/*var ajaxRequest=new XMLHttpRequest();
		ajaxRequest.open("GET","data/activity.json",true)
		//ajaxRequest.send(null)	
		while(ajaxRequest.readyState ===1){			//当有发出open请求 readyState为1
			alert(1)								//无限弹1,当然永远也轮不懂send运行
		}											//ajaxRequest.readyState ==4也是不行的 
													//所以需要引入事件监听脱离同步任务
		ajaxRequest.send(null)						//异步任务在同步任务全部完成后执行*/
		
		//readyState,onreadystatechange都是要依赖异步的send函数发回来的状态,不过时间很快,
		//onreadystatechange对应的函数相当于send的回调函数,要在send执行后才能执行
		//(这就是事件监听的用处)
		
		
		
		var a=10;
		
		var ajaxRequest=new XMLHttpRequest();
		ajaxRequest.open("GET","data/activity.json",true)
		ajaxRequest.send(null)	
		ajaxRequest.onreadystatechange=function(){  //异步事件队列返同步任务对的事件监听
			console.log("我是ajax请求回来触发事件监听的标志")
			console.log("异步任务ajax请求回来触发事件监听的时刻",new Date().getTime()-c)
		}
		
		
		setTimeout(function(){
			console.log("同步任务执行完0.004秒后立刻执行,setTimeout函数实际的延时时间会有偏差")
			console.log("异步任务setTimeout执行的时刻",new Date().getTime()-c)
			a++
			console.log("异步队列返回同步队列,a="+a);

		},0)
		
		
	
		
		console.log("同步任务","a="+a)
		var four = new Date();
		var c = four.getTime()
		for(var i=0;i<1000000000;i++){
			if(i === 0){
				console.log("同步任务,i=0时执行的时刻:",new Date().getTime()-c)
			}
			if(i === (1000000000-1)){
				console.log("同步任务,i=999999时执行的时刻:",new Date().getTime()-c)
				console.log("ajax的send()是在我执行完它才开始请求的,并不是我在进行的同时它也在请求,所以send()函数放在脚本的结尾和现在是一样的效果")
			}
		}
		//ajaxRequest.send(null)	
		
	</script>
</html>
