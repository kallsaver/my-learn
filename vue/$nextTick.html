<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			*{margin:0;padding: 0;}
			li{
				list-style: none;line-height: 50px;background: peru;margin-bottom: 50px;
				font-size: 20px;text-align: center;color: #fff;
			}
			.box{
				width:100px;height: 100px;background: green;
			}
		</style>
	</head>
	<body>
		<div id="app">
			<ul v-if="show">
				<li v-for="item of product" v-text="item.name"
					v-on:click="liClick()" ></li>
			</ul>
			<div class="box" v-on:click="changeProduct()">增加li</div>
		</div>
	</body>
	<script src="js/vue2.0.js"></script>
	<script>
		
		var app = new Vue({
			el : '#app',
			data : {
				product : [
					{ name : 'a' , price : 300 },
					{ name : 'b' , price : 100 },
					{ name : 'c' , price : 150},
					{ name : 'd' , price : 200 },
				],
				show : true,
			},
			created() {
				var vm = this;
				console.log('created');
				// 如果这个钩子函数没有vue的DOM元素中渲染
				// 基于Promise A+机制运行Promise.reslove
				vm.$nextTick(function(){
					console.log('created的$nextTick1');
				});
				vm.$nextTick(function(){
					console.log('created的$nextTick2');
				});
			},
			mounted(){
				var vm = this;
				console.log('mounted');
				// $nextTick是监听数据在vue的DOM元素中渲染完成触发
				// 一旦触发了$nextTick就取消了回调函数中内容的绑定
				// 但是如果多个$nextTick在vue的on事件中调用,会造成前面的$nextTick一直没有触发而冲掉后面的$nextTick
				vm.$nextTick(function(){
					console.log('mounted的$nextTick');
				});
				
			},
			methods : {
				changeProduct : function(){
					var vm = this;
					vm.product.push({ name : 'e' , price : 300 });
					vm.$nextTick(function (){
						console.log('div的点击$nextTick');
					});
				},
				liClick : function(){
					var vm = this;
					// 当没有DOM更新,$nextTick的回调函数就是Promise.resolve()的then的回调函数
					var promise1 = Promise.resolve();
					promise1.then(function () {
						console.log('then1');
					});
					
					vm.$nextTick(function(){
						console.log('li的点击$nextTick');
					});
					console.log('li click');
					
					// 当没有DOM更新,$nextTick的回调函数就是Promise.resolve()的then的回调函数
					var promise2 = Promise.resolve();
					promise2.then(function () {
						console.log('then2');
					});
				}
			},
			updated() {
				console.log('updated');
			},
			watch : {
				product : {
					deep : true,
					handler : function(newVal,oldVal){
						//console.log(77);
						// 同一个指针
						//console.log(newVal === oldVal)
					}
				}
			},
//			watch : {
//				product : {
//					handle : function(){
//						console.log(44)
//					}
//				}
//			}
		});
		
		// 只执行一次,监听数据->视图的渲染完成,可以多次使用,
		// $nextTick的正确使用方法不应该放在全局的同步任务中,没有任何意义
		// $nextTick表示每一次的vue实例的data里面的数据更新一次所走流程的结束
		// 正确的使用方法是放在点击函数,ajax,mounted中第三方修饰DOM这些函数中
		
		app.$nextTick(function(){
			console.log('全局的$nextTick1')
		});
		app.$nextTick(function(){
			console.log('全局的$nextTick2')
		});
		app.$nextTick(function(){
			console.log('全局的$nextTick3')
		});
		
//		app.$watch('product',function(val){
//			console.log(44)
//		})

		console.log('同步任务');
		
	</script>
</html>
