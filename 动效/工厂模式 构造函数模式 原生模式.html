<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>
</head>

<body>
<script>
	//工厂模式    无法判断是不是某个对象的实例   或者直接是Object的实例
	function fact(n,i){
		var student=new Object();
		 student.name=n;
		 student.iq=i;
		 return student;
	}
	
	var a=fact("likang",125);
	
	var b=fact("dongtao",250);
	
	console.log(a)
	console.log(b)
	console.log(a.constructor.name) //Object
	console.log(a instanceof fact) //false
	console.log(a instanceof Object) //true
	
	//构造函数模式:   传不同的参数 改造成不同的参数的对象
	//声明一个自定义原形    constructor
	function person(n,i){
		this.name=n;     //this指的是实例
		this.iq=i;
		this.sayname=function(){
			alert(1)
		}
	}
	
	var person1=new person("likang",125);
	var person2=new person("dongtao",250);
	console.log(person1)
	console.log(person2)
	console.log(person1.constructor.name)  //person
	console.log(person1 instanceof person) //true
	console.log(person1 instanceof Object) //true
	//构造函数的缺陷是实例中的方法,属性都是实例自己的   于是有了原生模式 
	
	
	//原生模式:   把属性和方法都直接添加到原形对象中  所有的实例都共享(继承)这些属性和方法     
	//不需要传参
	//原生模式还可以改良  就是和构造模式结合   私有的属性和方法传参  共享的属性和方法不传参
	function jquery(){}
	
	jquery.prototype.name="mike";
	jquery.prototype.age="29";
	jquery.prototype.addClass=function(){
		alert(2)
	}
	
	var jq1=new jquery(); 
	//私有函数不冲突 
	jq1.addClass=function(){
		alert(3)
	}
	//jq1.name="look"		//"look"来自实例
	//先从jq1的属性中找name  如果没有就到原形中找 然后再从Object中找
	console.log(jq1);     //"mike"来自原形
	console.log(jq1.constructor.name)  //jquery
	console.log(jq1 instanceof jquery) //true
	console.log(jq1.__proto__)
	
	

</script>
</body>
</html>
