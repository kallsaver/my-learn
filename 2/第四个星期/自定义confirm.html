<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>
<style>
*{margin:0px;padding:0px;font-size:0px;}
.pop{width:300px;height:150px;border:1px solid #ccc;border-radius:7px;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;z-index:11;background:#fff;}

.pop h3{text-align:center;line-height:90px;font-size:16px;}

.pop button{margin:0px 20px;width:70px;height:30px; line-height:30px;border:1px solid #ccc;font-size:12px;}

.modal{height:100%;background:#000;position:fixed;z-index:10;width:100%;top:0px;opacity:0.3;}
</style>
<script>
window.onload=function(){
	var obox=document.getElementById("box");
	
	
	obox.onclick=function(){
		_this=this;
		userconfirm("你确定删除box吗?",function(){
			 document.body.removeChild(_this);
		});
			
		
	}
}


	function modallayer(){
				
		var omodal=document.createElement("div");
		omodal.className="modal";
		document.body.appendChild(omodal);
		//把模态层的对象返回 就模态层这个对象的变量就可以在调用它的函数里面操作了 但是这个变量没有在上一级申明 
		//所以要在上一级函数(调用的函数)申明一次
		
		//而改进这种方法的做法就是return 一个函数出去 所谓的闭包 这样变量就不用再次在上一级申明了?
		return omodal;
	}
	
	function userconfirm(text,fn){
		//这里的omodal和modallayer的omodal是不一样的变量  
		var omodal=modallayer();
		var opop=document.createElement("div");
		opop.className="pop";
		opop.innerHTML='<h3>'+text+'</h3>'+
  							'<button>确定</button>'+
  							'<button>取消</button>' 
		document.body.appendChild(opop);
		var aButton=opop.getElementsByTagName("button");
		aButton[0].onclick=function(){
			document.body.removeChild(opop);
			document.body.removeChild(omodal);
			//如果有这个函数 就运行这个函数
			fn&&fn();
		}
		
		aButton[1].onclick=function(){
			document.body.removeChild(opop);
			document.body.removeChild(omodal);
		}
	}
</script>

</head>

<body>
<div id="box" style="width:200px;height:200px;background:red"></div>



</body>
</html>