<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style>
			ul{list-style: none;}
		</style>
		<script src="js/angular.js"></script>
		<script>
		var abc;
			angular.module("myApp",[],function(){
				
			})
			
			.directive('bookList',function(){
				return {
					restrict : "ECAM",
					replace : true,
					controller : function($scope){
						//console.log($scope.$id)  //$id:3
						//console.log($scope)
						this.addBook = function(){
							//alert(1)
							$scope.$apply(function(){
								$scope.bookList.push({name : 'Angularjs'})
							})
							
						};
						/*console.log($scope.a() == abc)   //true  拿到就是myCtrl中$scope.bookList的地址
						$scope.bookList =$scope.a()
						$scope.bookList.push({name : 'node'})   //通过栈地址操作堆地址
						$scope.bookList = null					//仅仅是这个变量的栈地址丢失  不影响同样栈地址的其他变量*/
						//1&.这个bookList不是myCtrl的bookList,因为$scope不是同一个$scope,并且不能通过作用域链继承
						//$scope.bookList = $scope.a()
						//2=.把$scope.b的引用地址清空,即myCtrl的$scope.bookList的地址也清空
						//$scope.b=null              	//这个很吊,有点违反js的常识,应该是监听b的变化,映射到$scope.bookList
						//$scope.bookList = $scope.b;
						//$scope.bookList = null                 //仅仅是这个变量的栈地址丢失  不影响同样栈地址的其他变量*/
						//$scope.b.push({name : 'node'})
						//3@.引用简单数据类型(string),所以是单向的
						/*console.log(typeof $scope.c)
						$scope.bookList = JSON.parse($scope.c) 
						console.log($scope.d)*/
						$scope.bookList = [
							{name : 'php1'},
							{name : 'javascript1'},
							{name : 'python1'},
						];
						
					},
					//scope指的是directive的controller函数的$scope
					//scope:false表示directive的controller中的$scope是父元素myCtrl的$scope
					//scope:true表示directive会自己创建一个新的作用域$scope,可以通过作用域链访问(继承)到myCtrl这个父元素的$scope
					//scope :true,
					//scope:object表示会自己创建一个新的作用域,并且默认无法享用继承链
					scope :{
						//&:作用域把一个属性包装成一个函数,从而以函数的方式读写父作用域$scope的属性,函数运行会返回父作用域$scope属性的值
						//=:作用域的属性与父作用域的属性进行双向绑定,任何一方的修改均影响到对方
						//@:只能读取父作用域里的值单项绑定
<<<<<<< HEAD
						//a :'&book'   		//1.将book属性封装成一个directive中的a函数
						//b : '=parentBook'   //2.将parentBook属性拿到的myCtrl父级的属性引用赋给b,任何一方属性的数据改变都会影响对方
=======
						//a :'&book'   		  //1.将book属性封装成一个directive中的a函数
						//b : '=parentBook'   //2.将父级的myCtrl的parentBook属性的引用赋给自定义指令scope.b,任何一方属性的数据改变都会影响对方
>>>>>>> b5dcfc604a02ad5743b54b114891c28460b72931
						/*c : '@parentTitle',
						d : '@zhname'*/
					},
					controllerAs : "bookListCtrl",
					//template不能写成平行元素,必须有个root element即最外围的元素  否则link中的element就找不到匹配的元素
					template :'<div><ul><li ng-repeat="book in bookList">{{book.name}}</li></ul></div>',
					link :function(scope){
<<<<<<< HEAD
						console.log(scope.bookList)
=======
						console.log(scope.bookList);
						//console.log(scope.b)
>>>>>>> b5dcfc604a02ad5743b54b114891c28460b72931
					}
							
				}
			})
			
			
			
			.controller("myCtrl",['$scope',function($scope){
				//console.log($scope.$id)	    //$id:2	
				$scope.bookList = [
							{name : 'php'},
							{name : 'javascript'},
							{name : 'python'},
				];
				abc = $scope.bookList
				$scope.name = '张三'
			}])
			
		</script>
	</head>
	<body ng-app="myApp">
		<div ng-controller="myCtrl">
			<ul>
				<li ng-repeat="book in bookList">{{book.name}}</li>
			</ul>
			<!--$scope中的东西在属性''中是暴露的,{{}}的意思是把里面的值转为字符串-->
			<div book-list book="bookList" parent-book="bookList" parent-title='{{bookList}}' zhname='{{name}}'></div>
		</div>
	</body>
</html>
