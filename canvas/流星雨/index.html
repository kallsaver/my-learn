<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>流星雨</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    /* .bg {
      background-image: url("./images/starry-sky.jpg");
      background-size: cover;
    } */
  </style>
</head>
<body>
  <div class="bg">
    <canvas id="canvas"></canvas>
  </div>
</body>
<script>
  const DEFAULT_TIME_SLICE = 1000

  class Throttle {
    constructor(timeSlice = DEFAULT_TIME_SLICE, firstStartTime) {
      this.timeSlice = timeSlice
      this.firstStartTime = firstStartTime
      this.init()
    }
    init() {
      this.state = true
    }
    run(func) {
      if (!this.state) {
        return
      }
      if (this.firstStartTime && !this.first) {
        this.waitFirst = true
        this.firstStartTimer = window.setTimeout(() => {
          this.first = true
          this.waitFirst = false
          let currentTime = new Date().getTime()
          if (!this.lastTime || currentTime - this.lastTime > this.timeSlice) {
            this.lastTime = currentTime
            func()
          }
        }, this.firstStartTime)
        return
      }
      if (this.waitFirst) {
        return
      }
      let currentTime = new Date().getTime()
      if (!this.lastTime || currentTime - this.lastTime > this.timeSlice) {
        this.lastTime = currentTime
        func()
      }
    }
    destroy() {
      this.timeSlice = null
      this.lastTime = null
      window.clearTimeout(this.firstStartTimer)
      this.firstStartTimer = null
    }
  }

  let timeStart

  export const requestAnimationFrame =
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function (cb) {
      window.setTimeout(() => {
        let timeCurrent = new Date().getTime()
        if (!timeStart) {
          timeStart = timeCurrent
        }
        let timeElapsed = timeCurrent - timeStart
        cb(timeElapsed)
      }, 100 / 6)
    }

  function getRandomInt(min, max) {
    return Math.random() * (max - min + 1) + min | 0
  }

  // canvas background-size: cover的效果
  function canvasImageCoverPosition(contentWidth, contentHeight, containerWidth, containerHeight, offsetLeft, offsetTop) {
    // 源图w/h
    let contentRatio = contentWidth / contentHeight
    // 容器(canvas)w/h
    let containerRatio = containerWidth / containerHeight
    let resultHeight
    let resultWidth

    if (contentRatio > containerRatio) {
      // 如果不处理, w要压缩
      resultHeight = containerHeight
      resultWidth = containerHeight * contentRatio
    } else {
      // 如果不处理, h要压缩
      resultWidth = containerWidth
      resultHeight = containerWidth / contentRatio
    }
    return {
      width: resultWidth,
      height: resultHeight,
    }
  }

  function getRandom(min, max) {
    return Math.random() * (max - min + 1) + min
  }

  const meteorMap = {}

  let backgroundImage = new Image()
  backgroundImage.src = './images/starry-sky.jpg'

  const WIDTH = window.innerWidth
  const HEIGHT = window.innerHeight

  let canvas = document.getElementById('canvas')
  let context = canvas.getContext('2d')

  let backgroundCanvas = document.createElement('canvas')
  let backgroundContext = backgroundCanvas.getContext('2d')

  let coverCanvas = document.createElement('canvas')
  let coverContext = coverCanvas.getContext('2d')

  canvas.width = WIDTH
  canvas.height = HEIGHT

  backgroundCanvas.width = WIDTH
  backgroundCanvas.height = HEIGHT

  coverCanvas.width = WIDTH
  coverCanvas.height = HEIGHT

  window.throttle = new Throttle(2000)

  backgroundImage.onload = () => {

    let sourceWidth = backgroundImage.width
    let sourceHeight = backgroundImage.height

    let imagePosition = canvasImageCoverPosition(
      sourceWidth,
      sourceHeight,
      WIDTH,
      HEIGHT,
    )

    backgroundContext.drawImage(
      backgroundImage,
      0,
      0,
      imagePosition.width,
      imagePosition.height
    )

    coverContext.drawImage(
      backgroundImage,
      0,
      0,
      imagePosition.width,
      imagePosition.height
    )

    let imageData = coverContext.getImageData(0, 0, WIDTH, HEIGHT)

    let worker = new Worker('./worker.js')

    // 传递参数给worker.js
    worker.postMessage({
      width: WIDTH,
      height: HEIGHT,
      imageData: imageData
    })

    worker.onmessage = function (event) {
      let data = event.data
      let imageData = data.imageData
      coverContext.putImageData(imageData, 0, 0)
      loop()
    }

    worker.onerror = function (event) {
      console.log(event.filename, event.lineno, event.message)
    }

  }

  class Meteor {
    constructor({id, x, y, length, angle, speed, size} = {}) {
      this.id = id
      this.x = x
      this.y = y
      this.length = length
      this.angle = angle / 180 * Math.PI
      this.speed = speed
      this.size = size || this.length * getRandom(0.004, 0.006)
      this.init()
    }
    init() {
      this.state = true
      this.vx = -this.speed * Math.cos(this.angle)
      this.vy = this.speed * Math.sin(this.angle)
      this.alpha =  1
      this.lineWidth = this.size * 0.5
      this.headerRadius = this.length * this.size / 100

      this.colorsStopList = [
        {
          s: 0,
          r: getRandomInt(192, 195),
          g: getRandomInt(90, 100),
          b: getRandomInt(192, 195),
          a: 1
        },
        {
          s: this.headerRadius / this.length,
          r: getRandomInt(160, 170),
          g: getRandomInt(90, 100),
          b: getRandomInt(160, 170),
          a: 0.9
        },
        {
          s: this.headerRadius / this.length + 0.6,
          r: getRandomInt(70, 80),
          g: getRandomInt(30, 40),
          b: getRandomInt(60, 80),
          a: 0.6
        },
      ]
    }
    render() {

      context.save()
      context.translate(this.x, this.y)
      context.rotate(-this.angle)

      let startX = 0
      let startY = 0
      let endX = this.length
      let endY = 0

      let linearStyle = context.createLinearGradient(
        startX, startY,
        endX, endY
      )

      for (let i = 0; i < this.colorsStopList.length; i++) {
        let item = this.colorsStopList[i]
        let stop = item.s
        let color = `rgba(${item.r}, ${item.g}, ${item.b}, ${item.a})`
        linearStyle.addColorStop(stop, color)
      }

      context.fillStyle = linearStyle
      context.globalAlpha = this.alpha
      context.beginPath()
      context.arc(this.headerRadius, this.headerRadius, this.headerRadius, Math.PI / 2, Math.PI / 2 * 3)
      context.lineTo(this.length, this.headerRadius)
      context.closePath()
      context.fill()
      context.restore()

    }
    update() {
      // 超出视图范围销毁掉
      if (this.x < 0 || this.y > HEIGHT) {
        this.destroy()
      }

      this.x += this.vx
      this.y += this.vy

      // this.vx -= 0.15
      // this.vy += 0.15

      this.flowAway()
    }
    flowAway() {
      this.alpha -= 0.008
      if (this.alpha < 0) {
        this.alpha = 0
      }
    }
    draw() {
      if (this.state) {
        this.render()
        this.update()
      }
    }
    destroy() {
      this.state = false
      delete meteorMap[this.id]
    }
  }

  let n = 0

  function createMeteor() {
    n++
    let x = getRandomInt(500, WIDTH)
    let y = getRandomInt(10, 100)
    let length = getRandom(100, 120)
    let angle = getRandom(50, 60)
    let speed = getRandom(15, 20)
    let size = getRandom(1, 2)
    let meteor = new Meteor({n, x, y, length, angle, speed, size})
    meteorMap[n] = meteor
  }

  function drawMeteor() {
    for (let n in meteorMap) {
      let meteor = meteorMap[n]
      meteor.draw()
    }
  }

  function updateMeteor() {
    window.throttle.run(() => {
      let randow = Math.random()
      if (randow > 0.5) {
        let count = getRandomInt(3, 7)
        for (let i = 0; i < count; i++) {
          createMeteor()
        }
      }
    })
  }

  function fillBackground() {
    context.save()
    let pattern = context.createPattern(backgroundCanvas, 'no-repeat')
    context.fillStyle = pattern
    context.fillRect(0, 0, canvas.width, canvas.height)
    context.restore()
  }

  function fillCover() {
    context.save()
    let pattern = context.createPattern(coverCanvas, 'no-repeat')
    context.fillStyle = pattern
    context.fillRect(0, 0, canvas.width, canvas.height)
    context.restore()
  }

  function loop() {
    // 绘制背景
    fillBackground()
    // 绘制流星
    drawMeteor()
    // 绘制覆盖层(树木)
    fillCover()
    // 产生新的流星
    updateMeteor()
    requestAnimationFrame(loop)
  }

</script>
</html>
