<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>无标题文档</title>
</head>

<body>
</body>
<script src="util.js"></script>
<script>

	//错误的写法:
	//普通函数调用的this是window 有时候需要用call修正
	/*function run(){
		$.ajax("data.json",function(data){
			data=JSON.parse(data)
			//console.log(data)				//data拿到字面量数组
			//alert(this)   //object Window       匿名回调函数可以当做是主函数体的兄弟函数
			var a={product:[]}
			a.product=data;		
			console.log(a.product)
			return a	//a是run()中匿名私有函数中的变量  run结束私有函数的生命周期也结束了
		})				//即使在私有函数中return a  a一样会被回收  说明return只能return一级
	}
	
	var b=run();
	console.log(b)				//undefined*/
	
	
	/*//改造:
	function run(){
		return $.ajax("data.json",function(data){//这个return并没有用 主函数体中没return return要一级一级来
			data=JSON.parse(data)
			//console.log(data)				//data拿到字面量数组
			var a={product:[]}
			a.product=data;		//a.product拿到data的引用值  而不是data下数据堆地址的引用值
			console.log(a.product)		//同理data拿到的是主函数体没被return的(只是传参)变量的引用值
			return a//或者return data	//$.ajax结束 主函数体的变量被销毁  所以a和data拿到的都是空值
		})				 
	}							//
	
	var b=run();
	console.log(b)				//undefined*/
	
	//正确的做法1:
	
	/*function run(){
		var a={product:[]}		//这里不能var a={}
		
		$.ajax("data.json",function(data){
			a.product=data;         //这里不能var a=data;  a拿到data的引用地址
		})						//同理是因为运行完data是要被销毁的  a只能拿到空的东西
		
		return a			//应该把data封在a的二维中  这样data的生命周期才和a一样
							//有二维结构的对象类似DOM元素 但是DOM元素的数据生命周期是window
							//二维结构对象的数据的生命周期取决于这个对象的生命周期
		
	}
	
	var b=run()
	
	console.log(b)*/
	
	//正确的做法2:
	var k=[];		//只开辟了栈地址 没有开辟堆地址
	
	function run(){
		var a=[];	//只开辟了栈地址 没有开辟堆地址
		var m=[];  //var k=[]
		//var c={product:[]}
		$.ajax("data.json",function(data){  //这个封装得到的是data的数据类型是string
			data=JSON.parse(data)        //json文本内容转成js对象(数组)
			//console.log(data)	//ajax请求的数据会再ajax函数运行完就主动销毁的	
			//a=data	//a没有开辟新的堆地址  要保存一个对象数据,不能用一维,要用二维结构
			
			//c.product=data;		//可以这样
			//a.push(data)			//a开辟了新的堆地址存放json的栈地址
			k[0]=data;				//或者这样
			Array.prototype.push.apply(a,data)			//最优美的写法
			
			//k[0][0].title="aaa"; 	
			//console.log(data[0].title)	//"aaa"	说明a和k都只是拿到json的引用 () 			
		})
		
		return a; 
	}
	
	var b=run();
	console.log(b)
	console.log(k)		//可以用数组的原型apply哦


//总结:要保存ajax请求回来的一个对象b的数据或者是通过函数传参过来的数据时   不能var a={}  a=b; 
//稳妥的做法是   var a=[] a.push(b) 或者var a={product:{}}  a.product=b
</script>
</html>
