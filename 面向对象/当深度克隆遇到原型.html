 <!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>
</head>

<body>
</body>
<script>
	function man(){
		this.firstType="a man"
	}
	
	

	function student(){
		this.type="a student";
		this.name="mike";
		this.age="20";
		this.skill=function(){
			alert(1)
		};
		this.address={
			city:"beijing"
		};
		this.hobby=["reading","sleeping"];
		
	}
	student.prototype=new man()
	
	student.prototype.speak=function(){		//man层
			alert("i am a student")
	}
	
	var person=new student();
	
	
	

	
	//判断类型的函数
	function isClass(o){
		if(o===null){ return "null"}
		if(o===undefined){return "undefined"}
		//Object.prototype.toString.call(o)出来的是"[object Object]"
		//Object.prototype.toString.call(o)出来的是"[object String]"
		//Object.prototype.toString.call(o)出来的是"[object Array]"
		//字符串的slice() 第二个参数写负数 可以返回后方的所有元素
		return Object.prototype.toString.call(o).slice(8,-1);
	}

	//深度克隆函数
	function deepClone(obj){
		//只处理两种情况  obj是数组或者对象的时候
		var result={},oClass=isClass(obj);
		if(oClass==="Object"){result={}}
		else if(oClass==="Array"){result=[]}
		else{return obj};

		for(var key in obj){
			//if(key==="g")alert("0")
			console.log(key) //10次     //0和1是哪里来的？1
			if(key=="0")alert("0")
			var copy=obj[key];
			if(isClass(copy)==="Object"){
				result[key]=arguments.callee(copy); //递归调用 deepClone  多维
				//alert(arguments.callee)
			}
			else if(isClass(copy)==="Array"){
				result[key]=arguments.callee(copy);
			}
			else{result[key]=obj[key]}			
		}
		return result;
	}
	

	var person1=deepClone(person)
	console.log("--------------------------------------------")
	console.log(person)		//person是个student 然后再是个object 
	console.log(person1)   //person1是个Object  所有非底层Object的方法属性都放在上层Object  因为person1得到的是result的地址
	person1.address.city="shenzhen";
	alert(person.address.city)
	person.speak()			//alert("i am a student")
	person1.speak()			//alert("i am a student")
	//但是person和person1还是有区别  
	console.log(person instanceof student)  //true
	console.log(person1 instanceof student)	//false

</script>
</html>
