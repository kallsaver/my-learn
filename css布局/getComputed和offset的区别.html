<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
			*{
				margin:0;
				padding:0;
			}
			.border {
				box-sizing: border-box;
			}
			.content {
				box-sizing: content-box;
			}
			.father {
				width: 200px; 
				height:200px;
				padding: 50px;
				background: peru;
				margin-bottom: 50px;
				border: 10px solid green;
			}
			.son {
				width: 100%;
				height:100%;
				background:cadetblue;
			}
			.small {
				width:20px;
				height: 20px;
				background:gold;
				padding: 10px;
			}
		</style>
	</head>
	<body>
		<div class="border father">
			<div class="son">
				<div class="small"></div>
			</div>
		</div>
		<div class="content father">
			<div class="son"></div>
		</div>
	</body>
	<script>
		
		var father = document.getElementsByClassName('father');
		
		// getComputedStyle是统一行内样式和行外样式,但是不是视图的width,是数据的width,只能读
		// 并且是带px单位的,调用这个方法浏览器会重排
		console.log(getComputedStyle(father[0]).width);
		
		// style是查找行内样式,可以读写,调用这个方法浏览器不会重排
		console.log(father[0].style.width);
		
		// 读取视图的width,包含了width,padding,border
		// 调用这个方法浏览器会重排,数据类型是number,推荐使用
		console.log(father[0].offsetWidth);
		
		console.log(getComputedStyle(father[1]).width);
		
		console.log(father[1].offsetWidth);
		
		
		var small = document.getElementsByClassName('small')[0];
		
		//子元素无法继承box-sizing
		console.log(getComputedStyle(small).boxSizing);
		
		
		// 在开源项目中,通常box-sizing是默认的,
		// 但是border-box盒子模型更好用
		// 解决方案是在less预编译器上利用&语法,对所有项目css加前缀,加前缀的box-sizing是border-box
		// 或者使用默认的content-box
		// https://segmentfault.com/q/1010000014689505?utm_source=tag-newest
	</script>
</html>
