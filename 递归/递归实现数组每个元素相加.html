<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
	<script>
	//实现数组的每个元素相加:		+是递归函数的功能  
		function sum(arr,index){
			
			if(index==1){
				return arr[0]
			}
			else{
				//由此可见 要写结构好打理的递归  arr[index-1]就是sum(arr,index-1)的"提取值"
				return arr[index-1]+arguments.callee(arr,--index)
			}
			
		}
		var arr=[1,2,3,4,5]
		console.log(sum(arr,arr.length))
		//如果要实现复杂的功能  不是+ 那么就要用到函数了   而这个函数就是外面函数的回调函数(因为它要作为参数递归传下去)
		//并且主函数的递归的缺陷是一定要传number值  而且不好搭结构    
		//最好的递归方式应该是主函数控制回调函数的循环 写得活而且可扩展可维护可实现复杂的功能可更改回调的内容又可以实现新的功能
		//reduce函数的强大之处是回调函数是业务部分  从回调函数的功能可以看出主函数是干什么的 
		//reduce的精华就是主函数和回调函数的return配合  		return prev=fn(prev) 
		
		//现在我想弄一个函数  可以实现da(arr1,arr2,arr3..)  可以返回一个新的数组  并且这个新的数组里面的所有元素都是不同的
		//用上面的函数格式只能da的参数没有回调函数  所以可以肯定da是个大函数  它里面还有小函数  小函数有回调函数实现递归大函数的参数
		//先写小函数的实现
		
		var arr1=[1,2,5,3];
		var arr2=[8,5,9,3,0];
		var arr3=[9,5,1,0];
		//总结:主函数是封装重复代码 和设计函数结构的   回调函数是写实现功能的
		//回调函数要写的内容越少  这个函数越是好好函数	但同时回调函数写的内容越少 可能主函数功能越专一化
		Array.prototype.run=function (fn){
			var length=arguments.length;
			var result=arguments[1];
			var provider={
				filterRepeat:function(arr){
					for(var i=0;i<arr.length;i++){
						
					}
				},
				
			}
			for(var i=1;i<length;i++){
				return result=fn(result,arguments[i+1],provider)
			}
					
		}
		
		//功能多样的:
		run(function(a,b,c){
			c.filterRepeat(a);
			c.filterRepeat(b)		
		},arr1,arr2,arr3)
	</script>
</html>
