<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
	<script>
		var arr1=[1,2,5,3,"5"];
		var arr2=[8,5,9,3,0];
		var arr3=[9,5,1,0];
		//总结:主函数是封装重复代码 和设计函数结构的   回调函数是写实现功能的
		//回调函数要写的内容越少  这个函数越是好好函数	但同时回调函数写的内容越少 可能主函数功能越专一化
		function run(fn){
			var length=arguments.length;
			var result=arguments[1];
			var provider={
				filterRepeat:function(result){		//这个result是新var出来的  拿到回调函数中result的地址
					var filter=[];
					for(var i=0;i<result.length;i++){
						if(filter.indexOf(result[i])===-1){
							filter.push(result[i])
						}				
					}
					//console.log(filter)
					//设计的时候想到把新数组给result  这样写的好处是回调函数部分写得更简单 
					//实际上传进主函数的result改变了 ,但是传进来的result其实是个一维的克隆不是回调函数的那个result
					//result=filter;   设计框架时要避免传进来的一维结构的地址丢失
					//正确的做法:
					result.length=0;	//把result原有的数据清空;
					result.push.apply(result,filter)							
				},
				
			}
			
			for(var i=2;i<length;i++){
				result=fn(result,arguments[i],provider)
			}
			return result;		
		}
		
		//功能多样的:
		var arrnew=run(function(a,b,c){	//c是工具包
			var result=[];
						//由于主函数体工具包的功能   result会被filter方法所改变	不需要result=c.filterRepeat(a);
			
			//a.push.apply(a,b)			//一种不需要var result的方法  用a来接收返回值
			//return a;		
			result.push.apply(result,a);
			result.push.apply(result,b);
			c.filterRepeat(result)				//回调传主函数   传的是引用地址
			return result;
		},arr1,arr2,arr3)
		
		console.log(arrnew)
		
		
		//总结:主函数传回调  如果是引用类型数据,拿的是引用值
		//而回调函数传主函数  如果是引用类型数据,拿的是一个实现一维克隆的的值    所以在回调函数return的时候   一定要return一个二维结构的数据  
		
	</script>
</html>
